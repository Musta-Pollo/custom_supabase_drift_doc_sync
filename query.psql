CREATE OR REPLACE FUNCTION push_changes (
    _changes JSONB,
    last_pulled_at TIMESTAMP WITH TIME ZONE
) RETURNS TIMESTAMP WITH TIME ZONE AS $$
DECLARE
    _updated_collections TEXT[];
    _purgatory BOOLEAN;
    _user_id UUID;
    _now_utc TIMESTAMP WITH TIME ZONE;
    _sql TEXT;
BEGIN
    -- Log the input _changes
    RAISE LOG 'push_changes: Input _changes: %', _changes;

    -- GET USERID and current time
    SELECT auth.uid() INTO _user_id;
    _now_utc := NOW();

    -- Log the user ID and current time
    RAISE LOG 'push_changes: User ID: %, Current UTC time: %', _user_id, _now_utc;

    -- Look in all collections that include at least one created or updated element
    SELECT array_agg(key ORDER BY key)
    INTO _updated_collections
    FROM jsonb_each(_changes)
    WHERE (
        -- Check if the 'created' array is not empty
        (jsonb_array_length(COALESCE(value->'created', '[]')) > 0) 
        -- Check if the 'updated' array is not empty
        OR (jsonb_array_length(COALESCE(value->'updated', '[]')) > 0)
    )
    AND to_regclass(format('%I.%I', split_part(key, '.', 1), split_part(key, '.', 2))) IS NOT NULL;

    -- Log updated collections after the filtering
    RAISE LOG 'push_changes: Updated Collections: %', _updated_collections;

    IF _updated_collections IS NOT NULL AND array_length(_updated_collections, 1) > 0 THEN
        -- Prevent updates or inserts out of sequence
        EXECUTE (
            'SELECT ' || string_agg(format($f$
                EXISTS (
                    SELECT 1 FROM %I.%I
                    WHERE user_id = $1
                    AND deleted_at IS NULL
                    AND server_updated_at > $2
                )$f$, split_part(col, '.', 1), split_part(col, '.', 2)), E'\n')
        )
        FROM UNNEST(_updated_collections) col
        USING _user_id, last_pulled_at INTO _purgatory;

        -- Log the purgatory check for updates
        RAISE LOG 'push_changes: Purgatory (updated records check): %', _purgatory;

        IF _purgatory THEN
            RAISE EXCEPTION 'push_changes: Record was updated remotely between pull and push';
        END IF;

        -- Prevent creation out of sequence
        EXECUTE (
            'SELECT ' || string_agg(format($f$
                EXISTS (
                    SELECT 1 FROM %I.%I
                    WHERE user_id = $1
                    AND deleted_at IS NULL
                    AND server_created_at > $2
                )$f$, split_part(col, '.', 1), split_part(col, '.', 2)), E'\n')
        )
        FROM UNNEST(_updated_collections) col
        USING _user_id, last_pulled_at INTO _purgatory;

        -- Log the purgatory check for created records
        RAISE LOG 'push_changes: Purgatory (created records check): %', _purgatory;

        IF _purgatory THEN
            RAISE EXCEPTION 'push_changes: Record was created remotely between pull and push';
        END IF;

        -- Construct the SQL for inserting/updating records
        SELECT string_agg(format($f$
            INSERT INTO %I.%I (user_id, server_created_at, %3$s)
            SELECT $1, $2, %2$s
            FROM jsonb_populate_recordset(null::%I, COALESCE((($3)->%1$L)->'created', '[]') || COALESCE((($3)->%1$L)->'updated', '[]'))
            ON CONFLICT (id) DO UPDATE SET (server_updated_at, %2$s) = ($2, %3$s)
            WHERE %I.user_id = $1
        $f$, split_part(collection, '.', 1), split_part(collection, '.', 2), cols, excl, collection), E'\n')
        INTO _sql
        FROM (
            SELECT collection,
                   string_agg(quote_ident(attname), ',' ORDER BY attnum) AS cols,
                   string_agg(format('excluded.%I', attname), ',' ORDER BY attnum) AS excl
            FROM UNNEST(_updated_collections) collection
            JOIN pg_attribute att ON (attrelid = to_regclass(format('%I.%I', split_part(collection, '.', 1), split_part(collection, '.', 2)))
            WHERE attnum > 0
            AND attname NOT IN ('user_id', 'server_created_at', 'server_updated_at', 'deleted_at')  -- these are handled separately
            AND NOT attisdropped
            GROUP BY collection
            ORDER BY collection
        ) x;

        -- Log the constructed SQL statement
        RAISE LOG 'push_changes: Constructed SQL for insert/update: %', _sql;

        -- Execute the constructed SQL
        EXECUTE _sql USING _user_id, _now_utc, _changes;
    END IF;

    -- Delete all records with "deleted" values in one execution
    SELECT array_agg(key ORDER BY key)
    INTO _updated_collections
    FROM jsonb_each(_changes)
    WHERE COALESCE(value->'deleted', '[]') <> '[]'
    AND to_regclass(format('%I.%I', split_part(key, '.', 1), split_part(key, '.', 2))) IS NOT NULL;
    

    -- Log collections that will be deleted
    RAISE LOG 'push_changes: Collections to delete: %', _updated_collections;

    IF _updated_collections IS NOT NULL AND array_length(_updated_collections, 1) > 0 THEN
        -- Construct the SQL for deleting records
        SELECT string_agg(format($f$
            UPDATE %I.%I
            SET deleted_at = $2
            FROM jsonb_array_elements_text((($3)->%1$L)->'deleted') del
            WHERE user_id = $1
            AND id = del
            AND deleted_at IS NULL;
        $f$, split_part(collection, '.', 1), split_part(collection, '.', 2)), E'\n')
        INTO _sql
        FROM UNNEST(_updated_collections) collection;

        -- Log the constructed SQL for delete statements
        RAISE LOG 'push_changes: Constructed SQL for delete: %', _sql;

        -- Execute the constructed SQL for delete
        EXECUTE _sql USING _user_id, _now_utc, _changes;
    END IF;

    RETURN _now_utc;
END;
$$ LANGUAGE plpgsql;
